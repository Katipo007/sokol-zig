//! helper tool invoked from buil.zig to remove the Zig stdlib sources
//! from the 13 MBytes sources.tar file generated by Zig auto-doc generation
//! (and instead only have the actual sokol-zig sources in the archive)
const std = @import("std");

pub fn main() !void {
    var arena_state = std.heap.ArenaAllocator.init(std.heap.page_allocator);
    defer arena_state.deinit();
    const arena = arena_state.allocator();

    std.log.info("=> remove std sources from generated sources.tar file", .{});

    // parse args
    var opt_prefix: ?[]const u8 = null;
    var opt_input_path: ?[]const u8 = null;
    var opt_output_path: ?[]const u8 = null;
    var arg_iter = try std.process.argsWithAllocator(arena);
    defer arg_iter.deinit();
    while (arg_iter.next()) |arg| {
        if (std.mem.eql(u8, "--input", arg)) {
            opt_input_path = arg_iter.next() orelse fatal("expected [path] after --input", .{});
        } else if (std.mem.eql(u8, "--output", arg)) {
            opt_output_path = arg_iter.next() orelse fatal("expected [path] after --output", .{});
        } else if (std.mem.eql(u8, "--prefix", arg)) {
            opt_prefix = arg_iter.next() orelse fatal("expected [prefix] after --prefix", .{});
        }
    }
    const input_path = opt_input_path orelse fatal("expected --input [path] arg", .{});
    const output_path = opt_output_path orelse fatal("expected --output [path]", .{});
    const prefix = opt_prefix orelse fatal("expected --prefix [prefix]", .{});
    std.log.info("input path: {s}", .{input_path});
    std.log.info("output path: {s}", .{output_path});
    std.log.info("prefix: {s}", .{prefix});

    // iterate over sources.tar file, find relevant files and write to output tar file
    var dir = std.fs.openDirAbsolute(input_path, .{}) catch fatal("failed to open dir {s}", .{input_path});
    defer dir.close();
    const inp_file = dir.openFile("sources.tar", .{}) catch fatal("failed to open 'sources.tar' in dir {s}", .{input_path});
    defer inp_file.close();
    const outp_file = std.fs.createFileAbsolute(output_path, .{}) catch fatal("failed to open output file {s}", .{output_path});
    defer outp_file.close();
    var tar_writer = std.tar.writer(outp_file.writer());

    var file_name_buffer: [1024]u8 = undefined;
    var link_name_buffer: [1024]u8 = undefined;
    var iter = std.tar.iterator(inp_file.reader(), .{
        .file_name_buffer = &file_name_buffer,
        .link_name_buffer = &link_name_buffer,
    });
    while (try iter.next()) |tar_item| {
        switch (tar_item.kind) {
            .file => {
                if (std.mem.startsWith(u8, tar_item.name, prefix)) {
                    std.log.info("extracting file: {s}", .{tar_item.name});
                    try tar_writer.writeFileStream(tar_item.name, tar_item.size, tar_item.reader(), .{ .mode = tar_item.mode });
                }
            },
            else => continue,
        }
    }
    std.log.info("=> done.", .{});
    return std.process.cleanExit();
}

fn fatal(comptime fmt: []const u8, args: anytype) noreturn {
    std.log.err(fmt, args);
    std.process.exit(5);
}
